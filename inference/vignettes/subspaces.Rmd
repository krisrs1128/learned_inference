---
title: "Stability Selection & Subspaces"
output: html_notebook
---

```{r}
library("PMA")
library("dplyr")
library("ggplot2")
library("glmnet")
library("purrr")
library("readr")
library("reshape2")
library("reticulate")
library("stringr")
theme_set(theme_bw())
source("../R/stability.R")
```
First we read in all the relevant data.

```{r}
# unzip raw experimental output
data_dir <- "/Users/kris/Documents/stability_outputs/"
paths <- c(
  file.path(data_dir, "vae90.yaml_1.tar.gz"),
  file.path(data_dir, "vae90.yaml_2.tar.gz"),
  file.path(data_dir, "vae90.yaml_4.tar.gz")
)
untar_all(paths, data_dir = data_dir)

# read in response data and input image paths
output_dirs <- map(paths, ~ file.path(data_dir, tools::file_path_sans_ext(basename(.x))))
Xy <- read_csv(file.path(output_dirs[1], "Xy.csv"))
metadata <- map(output_dirs, ~ read_csv(file.path(.x, "vae90", "metadata.csv")))
subsets <- map(output_dirs, ~ read_csv(file.path(.x, "vae90", "features", "subset.csv")))
names(subsets) <- output_dirs
```
Next, let's identify the paths to all the activation numpy files. This involves

* merging all the `metadata.csv` files produced by individual runs
* annotating the bootstrap number associated with each run
* giving absolute and relative paths to the data

```{r}
metadata <- map(output_dirs, ~ cbind(abs_path = .x, read_csv(file.path(.x, "vae90", "metadata.csv")))) %>%
  map_dfr(~ .x %>% 
      mutate(
        model = str_replace(out_path, "(.+)stability_data/(.+)/features(.+)", "\\2"),
        rel_path = str_replace(out_path, "(.+)stability_data/(.+)", "\\2")
        )
  ) %>%
  mutate(
    bootstrap = str_replace(abs_path, "(.+)yaml_([0-9]+).tar", "\\2"),
    bootstrap = as.numeric(bootstrap),
    abs_path = file.path(abs_path, rel_path),
    source = str_replace(abs_path, "(.+)(tar)(.+)", "\\1\\2")
  ) %>%
  select(abs_path, source, model, bootstrap, epoch, layer)
```


Now, we'll read in the actual activations associated with each of the numpy
arrays referenced in the metadata file.
```{r}
np <- import("numpy")
acts_ <- metadata %>%
  filter(epoch == "best", layer == "mu") %>%
  .[["abs_path"]] %>%
  unique()
acts <- map(acts_, ~ data.frame(np$load(.x)))
```

```{r}
subsets_ <- map(subsets, ~ rename(., c("ix" = "X1", "rel_path" = "path")))
acts <- map2(subsets_, acts, cbind)
```

First, we'll get the projected scores, using MultiCCA.

```{r}
x_list <- map(acts, ~ .x %>% select(starts_with("X")) %>% as.matrix())
cca_res <- MultiCCA(x_list, ncomponents = 40)
scores <- map2(x_list, cca_res$ws, ~ .x %*% .y)
```

Before we can plot them, we need to merge them into a data.frame and tidy.

```{r}
scores2 <- map2_dfr(subsets_, scores, cbind, .id = "source")
plot_data <- scores2 %>%
  left_join(metadata %>% select(source, bootstrap) %>% unique()) %>%
  left_join(Xy, by = c("rel_path" = "path")) %>%
  select(bootstrap, rel_path, split, `2`, `3`, y) %>%
  melt(id.vars = c("bootstrap", "rel_path", "split", "y"), variable.name = "dim") %>%
  arrange(rel_path)
head(plot_data)
```


```{r}
#subsample <- nrow(plot_data)
subsample <- 800
centroids <- plot_data[1:subsample, ] %>%
  group_by(dim, rel_path, split, y) %>%
  summarise(mean = mean(value)) %>%
  mutate(dim = paste0("mean", dim)) %>%
  dcast(rel_path + split + y ~ dim, value.var = "mean")

edge_data <- plot_data[1:subsample, ] %>%
  dcast(bootstrap + rel_path + split + y ~ dim, value.var = "value") %>%
  split(.$bootstrap) %>%
  map_dfr(~ .x %>% left_join(centroids))
```


```{r, fig.width = 20}
ggplot(edge_data) +
  geom_point(
    data = centroids,
    aes(x = mean3, y = mean2, col = y),
    alpha = 0.5, size = 0.8
    ) +
  geom_point(
    aes(x = `3`, y = `2`, col = y),
    size = 0.9, alpha = 0.4
  ) +
  geom_segment(
    aes(x = `3`, xend = mean3, y = `2`, yend = mean2, col = y),
    size = 0.2, alpha = 0.5
  ) +
  coord_fixed(0.5) +
  facet_grid(split ~ .) +
  scale_color_viridis_c() +
  theme(legend.position = "bottom")
```

```{r}
regression_data <- scores2 %>%
  left_join(metadata %>% select(source, bootstrap) %>% unique()) %>%
  left_join(Xy, c("rel_path" = "path"))

```

```{r}
xy <- regression_data %>%
  split(., list(.$bootstrap, .$split)) %>%
  map(~ subset_matrices(.))

for (b in seq_along(xy)) {
  fit <- glmnet(x = xy[[b]]$X, y = xy[[b]]$y)
  y_hat <- predict(fit, newx = xy[[b]]$X, type = "response")
  plot(cv.glmnet(xy[[b]]$X, xy[[b]]$y))
  plot(xy[[b]]$y, y_hat[, dim(y_hat)[2]])
}
```
Now let's run stability selection on each split and bootstrap sample separately.

```{r}
lambda <- 2 ^ seq(-8, -1, length.out = 20)
selection_data <- map(xy, ~ stability_selection(.x$X, .x$y, B = 250, lambda = lambda))
pi_hat <- map_dfr(selection_data, ~ melt(t(.x$Pi), varnames = c("lambda", "j")), .id = "run") %>%
  tidyr::separate(run, c("bootstrap", "split"))
```

Below, we're plotting the number of times each feature is selected by the 250
lasso's above, as a function of $\lambda$.

```{r, fig.height = 20, fig.width = 6}
pi_hat <- pi_hat %>%
  tidyr::unite(jb, j, bootstrap, split, remove = FALSE)
ggplot(pi_hat %>% filter(j < 21)) +
  geom_line(aes(x = lambda, y = value, col = bootstrap, group = jb, linetype = split)) +
  scale_color_brewer(palette = "Set2") +
  facet_grid(j ~ split)
```
