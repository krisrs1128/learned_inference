---
title: "Stability Selection & Subspaces"
output: html_notebook
---

```{r}
library("PMA")
library("dplyr")
library("ggplot2")
library("glmnet")
library("purrr")
library("readr")
library("reshape2")
library("reticulate")
library("stringr")
theme_set(theme_bw())
source("../R/stability.R")
```
First we read in all the relevant data.

```{r}
# unzip raw experimental output
data_dir <- "/Users/kris/Documents/stability_outputs/"
paths <- c(
  file.path(data_dir, "vae90.yaml_1.tar.gz"),
  file.path(data_dir, "vae90.yaml_2.tar.gz")
)
untar_all(paths, data_dir = data_dir)

# read in response data and input image paths
output_dirs <- map(paths, ~ file.path(data_dir, tools::file_path_sans_ext(basename(.x))))
Xy <- read_csv(file.path(output_dirs[1], "Xy.csv"))
metadata <- map(output_dirs, ~ read_csv(file.path(.x, "vae90", "metadata.csv")))
subsets <- map(output_dirs, ~ read_csv(file.path(.x, "vae90", "features", "subset.csv")))
```
Next, let's identify the paths to all the activation numpy files. This involves

* merging all the `metadata.csv` files produced by individual runs
* annotating the bootstrap number associated with each run
* giving absolute and relative paths to the data

```{r}
metadata <- map(output_dirs, ~ read_csv(file.path(.x, "vae90", "metadata.csv"))) %>%
  map_dfr(~ .x %>% 
      mutate(
        model = str_replace(out_path, "(.+)stability_data/(.+)/features(.+)", "\\2"),
        rel_path = str_replace(out_path, "(.+)stability_data/(.+)", "\\2"),
        data_dir = str_replace(out_path, "(.+)(vae|cnn)(.+)", "\\1"),
        ),
  .id = "abs_path"
) %>%
  mutate(
    bootstrap = str_replace(abs_path, "(.+)yaml_([0-9]+).tar.gz", "\\2"),
    bootstrap = as.numeric(bootstrap),
    abs_path = file.path(tools::file_path_sans_ext(abs_path), rel_path)
  ) %>%
  select(abs_path, model, bootstrap, epoch, layer)


#%>%
#  mutate(
#    boot_path = tools::file_path_sans_ext(bootstrap),
#  ) %>%
#  tidyr::unite(path, boot_path, path, sep="") %>%
#  select(-bootstrap) %>%
#  select(path, layer, epoch) %>%
#  arrange(path, layer, epoch)

head(metadata)
```


Now, we'll read in the actual activations associated with each of the numpy
arrays referenced in the metadata file.
```{r}
np <- import("numpy")
acts_ <- metadata %>%
  filter(epoch == "best", layer == "mu") %>%
  .[["path"]] %>%
  unique()
acts <- map(acts_, function(x) data.frame(np$load(x)))
```

```{r}
subsets_ <- map(subsets, ~ rename(., c("ix" = "X1", "path" = "path", "split" = "split")))
acts <- map2(subsets_, acts, cbind)
```

First, we'll get the projected scores, using MultiCCA.

```{r}
x_list <- map(acts, ~ .x %>% select(starts_with("X")) %>% as.matrix())
cca_res <- MultiCCA(x_list, ncomponents = 40)
```
```{r}
scores <- list()
for (i in seq_along(x_list)) {
  scores[[i]] <- x_list[[i]] %*% cca_res$ws[[i]]
}
```

Before we can plot them, we need to merge them into a data.frame and tidy.
```{r}
scores2 <- map2_dfr(subsets_, scores, cbind, .id = "source") %>%
  mutate(B = str_extract(source, "yaml.{1,2}")) %>%
  mutate(B = as.integer(gsub("yaml_", "", B)))
head(scores2)

plot_data <- scores2 %>%
  select(B, path, split, `1`, `2`) %>%
  melt(id.vars = c("B", "path", "split"))

edge_data <- plot_data %>%
  dcast(path + split ~ variable + B)

plot_data <- plot_data %>%
  dcast(path + split + B ~ variable)

ggplot() +
  geom_segment(
    data = edge_data,
    aes(x = `1_1`, xend = `1_2`, y = `2_1`, yend = `2_2`),
    alpha = 0.8, size = 0.1
  ) +
  geom_point(
    data = plot_data,
    aes(x = `1`, y = `2`, col = as.factor(B)),
    size = 0.3, alpha = 0.8
  ) +
  facet_grid(split ~ .) +
  coord_fixed(.75) +
  scale_color_brewer(palette = "Set2") +
  theme(legend.position = "bottom")
```


```{r}
regression_data <- scores2 %>%
  left_join(Xy)
```

```{r}
subset_matrices <- function(rdata, b, cols = as.character(1:40)) {
  X <- regression_data %>%
    filter(B == b) %>%
    select(cols) %>%
    as.matrix()
  
  y <- regression_data %>%
    filter(B == b) %>%
    .[["y"]]
    
  list(X = X, y = y)
}

xy <- map(1:2, ~ subset_matrices(regression_data, .))

for (b in 1:2) {
  fit <- glmnet(x = xy[[b]]$X, y = xy[[b]]$y)
  y_hat <- predict(fit, newx = X, type = "response")
  plot(cv.glmnet(xy[[b]]$X, xy[[b]]$y))
  plot(xy[[b]]$y, y_hat[, dim(y_hat)[2]])
}
```
```{r}
stability_selection <- function(X, y, B = 1000, n_lambda = 100) {
  lambda <- glmnet(X, y)$lambda
  
  n <- nrow(X)
  p <- ncol(X)
  coef_paths <- array(dim = c(p + 1, length(lambda), B))
  for (b in seq_len(B)) {
    ix <- sample(seq_len(n), n / 2, replace = FALSE)
    fit <- glmnet(X[ix, ], y[ix], lambda = lambda)
    coef_paths[, , b] <- as.matrix(coef(fit))
  }

  Pi <- apply(coef_paths, c(1, 2), function(z) mean(abs(z) > 0))
  list(Pi = Pi, coef_paths = coef_paths)
}
```


```{r}
selection_data <- map(xy, ~ stability_selection(.x$X, .x$y, B = 250))
pi_hat <- map_dfr(selection_data, ~ melt(t(.x$Pi), varnames = c("lambda", "j")), .id = "B")
```

```{r}
pi_hat <- pi_hat %>%
  tidyr::unite(jb, j, B, remove = FALSE) %>%
  filter(j < 21)
ggplot(pi_hat) +
  geom_line(aes(x = lambda, y = value, col = B, group = jb)) +
  scale_color_brewer(palette = "Set2") +
  facet_wrap(~ j)
```

todos:

* Need to separate the selection process on different splits
* show the progression across many epochs
* Need to run with all the bootstrap samples
* Run with more than just the VAE

